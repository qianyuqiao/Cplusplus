### 类声明中的变量不能初始化，除非变量前面有const
```
class A
{
private:
	static int a = 1; // 错误
  const int a = 1; // 正确
  static const int a = 1; // 正确
}
```

### 对于简单数据类型，
### 比如char* p = new char[10], int* p = new int[10],delete p和delete[] p一样

### c++自动提供下面的成员函数
```
默认构造函数
默认析构函数
拷贝构造函数
赋值运算符 // 可以被重载
地址运算符 // 可以被重载
```

### 值传递时，拷贝构造函数调用几次?
我在gcc和vs32位下都试了一下
```
一次，相当于原始数据类型的压栈操作，在函数退出后立马析构
```

### 默认构造函数？？为什么只能有一个默认构造函数？？
```
没有任何参数的构造函数是默认构造函数
带有默认值的参数的构造函数也可以是默认的构造函数
A(int n = 0) {val = n;}
```

### 何时调用拷贝构造函数？？
```
A a;
A b(a); // yes
A b = a; // yes
A b = A(a); // yes
A* b = new A(a); // yes

A b;
b = a; // no ,赋值运算符。
```

### 浅拷贝？深拷贝？
浅拷贝
```
逐个复制非静态成员的值
```

### char c[2] = "11"为什么报错
因为其实是11\0

### const对象只能调用const方法
```
const A a;
a.print() // 报错，把print()改成print const就行了
```

### 对象不能调用静态成员函数，只能通过类名调用
```
static int print() {return a;} // 不能通过对象调用
int count = A::print();
```

### 下面的结果是什么？？
```
class A
{
private:
	int val;
	static int nums; // 初始化为0
public:
	A() { cout << "create" << endl; };
	A(int val);
	~A();
	void operator=(const A& b) { cout << "=" << endl; this->val = b.val; }
	void print() const {}
};

A::A(int a)
{
	val = a;
	cout << "trans create" << endl;
}
A::~A()
{
	cout << "delete" << endl;
}
int main()
{
	A a; // create
	a = 2; // trans create, = ,delete
	return 0; // delete
}
```
