### 友元类
```
class Man1
{
private:
	int val;
	friend class Man2;
};
class  Man2
{
public:
	Man1 man1;
	int get_man1_val() {
		return man1.val;
	}
};
```
友元类也不能继承

### 友元成员函数
```
class  Man2
{
public:
	int get_man1_val(const Man1& man1);
};
class Man1
{
private:
	int val;
public:
	friend int Man2::get_man1_val(const Man1&); // Man2的声明必须放在Man1前面，否则编译器是不知道Man2有没有成员函数get_man1_val1;
};

int Man2::get_man1_val(const Man1& man1) // 必须先定义后声明，否则不知道man1有没有val;
{
	return man1.val;
}
```

### 嵌套类和包含类
```
class A 
{
    class B // 包含类  
    {

    }
}
```
作用域如下
![image](https://github.com/qianyuqiao/Cplusplus/blob/master/C%2B%2Bprimerplus/img/123.PNG)

### 异常
1.abort()
```
if (a == b) std::abort(); // 程序异常终止
```
2.返回错误码
```
bool ans(int* code, int a)
{
	if (a == 0)
	{
		*code = DBL_MAX;
		return false;
	}
	return true;
}
```
3.异常处理
```
int add(int a, int b)
{
	if (a == b) { throw "a ==b"; }
	return 0;
}
int main()
{
	try
	{
		add(1, 1);
	}
	catch (const char* s)
	{
		cout << s << endl;
	}
	return 0;
}
```
4.抛出异常类
```
class C
{
private:
	int val;
public:
	C() {};
	C(const int & val1) { val = val1; }
	void print() { cout << "error code " << val << endl; }
};
int add(int a, int b)
{
	if (a == b) { throw C(1); }
	return 0;
}
int main()
{
	try
	{
		add(1, 1);
	}
	catch (C& c)
	{
		c.print();
	}
	return 0;
}
```

### RTTI
```
运行阶段类型识别
```

### c++三个支持RTTI的元素
dynamic_cast:
```
一般利用指向基类的指针生成指向派生类的指针，否则返回0；
```
typeid:
```
能够确定两个对象是否为同种类型
可以接受
类名
对象
typeid(A) == type(*pg);
pg是空指针时，程序将抛出bad_typeid异常（继承自exception）
```

### 通过typeid获取对象类名？？
```
A a;
cout << typeid(a).name() << endl; // 结果:class A;
```

### 再看bad_alloc??
```
int main () { 
  try
  { 
     int * myarray = new int[1000000000000]; 
  } 
  catch (std::bad_alloc & exception) // 抛出bad_alloc;
  { 
     std::cerr << "bad_alloc detected: " << exception.what(); 
  } 
  return 0; 
} 
```
