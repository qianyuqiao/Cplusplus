### 下面的代码能用吗？
```
int add(int* a) {return *a;}

int main()
{
    int a = add(1); // 错误，因为int不能转换为int*
}
```

### 模板重载
```
template <typename T>
int add(T& a)
{
	return a + 1;
}

template <typename T>
int add(T* a, int n)
{
	return *a + 1 + n;
}
```

### 模板函数的局限性
```
template <typename T>
int add(T a, T b)
{
if (a > b)//可能没有重载运算符。。怎么办
}
```

### 显式具体化
```
template <typename T>
int add(T& a)
{
	cout << "a+1" << endl;
	return a + 1;
}

template<> int add<int>(int&a)
{
	cout << "a+2" << endl;
	return a + 2;
}
```
结果:
```
a+2
```

### 具体化和实例化
实例化？？
```
显式实例化意味着可以直接命令编译器创建特定的实例
有以下两种方式
1.
template void Swap<int>(int &, int &);
2.
Swap<int>(a,b);比如：
template <typename T>
T add(T a, T b) { return a +b;}
int main()
{
	int a = 1;
	double b = 1;
	cout << add<double>(a, b) << endl;
这种情况下，把T a改成T& a就不行了。。。
T add(T &a, T& b) { return a +b;} // 不行
```

显示具象化：
```
template <> void Swap(job &a, job &b)
template <> void Swap<job>(job &a, job &b)
显式具体化在声明后，必须要有具体的实现，这是与显示实例化不同的地方。
```
显示具象化在template后面有<>，表示必须有实现

### 重载解析
```
1.创建候选函数列表
may('B');
以下候选

void may(int);
float may(float, float=3);
void may(char);
char* may(const char*); // 不能把char转换为char*
char may(const char&);
template<> void may(const T&);
template<> void may(T*); //不能把char转换为T*

2.从最佳到最差的顺序按下匹配
1.完全匹配
2.提升转换(char和shorts转换为int, float转换为double)
3.标准转换(int 转换为char, long 转换为double)
4.用户自定义转换
```

### 下面这些情况都是完全匹配
```
struct blot {int a; char b[10];};
blot ink = {25, "spots"};
...
recycle(ink);
```
下面这些情况都是完全匹配的
```
void recycle(blot);
void recycle(const blot);
void recycle(blot&);
void recycle(const blot&);
```
比如下面的情况
```
int add1(int a) { return a + 1;}
int add1(int& a) { return a + 2;}
```
这种情况下是有二义性的，会显示
```
有多个重载函数实例与参数列表匹配
```

### 非模板函数总是由于模板函数
如果两个完全匹配的函数都是模板函数，则较具体化的模板函数优先
```
显示具体化优于隐式具体化
template <typename T>
T add(T& a, T& b) { return a +b;}
template<> int add(int& a,  int& b){ return a+b+1;}

int main()
{
	int a = 1;
	int b = 2;
	cout << add(a, b) << endl;
	return 0;
}

输出3
```
下面这种情况也是匹配的
```
struct blot {int a; char b[10];};
blot ink = {25, "spots"};
...
recycle(&ink);

void recycle(T a); // 匹配 blot*
void recycle(T* a); // 匹配blot
这时候需要用到部分排序
```
3.自己排序
```
template <typename T>
T add(T a, T b) { return a +b;}
int add(int a, int b){return a + b + 1;}
int main()
{
	int a = 0;
	int b = 0;
	double c = 0.0;
	double d = 0.0;
	cout << add(a, b) << endl; // int add
	cout << add(c, d) << endl; // 模板
	cout << add<>(c, d) << endl; // 模板
	cout << add<int>(c, d) << endl; // 模板
	return 0;
}
```
答案：
```
1
0
0
0
```
