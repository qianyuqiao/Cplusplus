### 利用explicit关闭隐式类型转换
```
explicit Student(int n): name("Null"), scores(){}
否则
Student c = 5; 会调用Student(5);
```

### 构造函数中的冒号
1.对对象成员进行初始化
```
假如a有两个对象成员s1, s2,
表示先调用对象的构造函数,再调用自己的构造函数
class A
{
private:
    string s1;
    string s2;
}
A(): s1(), s2() {}
```
2.直接初始化成员变量
```
class A
{
private:
    int a;
    int b;
public:
    A(int x, int y): a(x), b(y);
}
```
3.子类调用基类的构造函数
```
A(): D() {};
```

### 构造函数的匹配
```
class C
{
private:
	double x;
public:
	C() {};
	C(double val) { x = val; }
};
int main()
{
    C(2); // ok,强制类型转换
}
```
当类的声明是下面这种就不行
```
class C
{
private:
	double x;
	float y;
public:
	C() {};
	C(double val) { x = val; } // 这两个都匹配，会产生矛盾
	C(float val) {}  // 这两个都匹配，会产生矛盾
};
```

### 构造函数产生临时对象
下面的答案是什么？？
```
class C
{
public:
	int x;
	C() {};
	C(int val) { cout << "C create" << endl;x = val; }
	C(const C& c) { cout << "C copy create" << endl; x = c.x; }
};
class D
{
	int x;
public:
	C c;
	D();
	D(const C& tmp) : c(tmp) { cout << "D create" << endl; x = tmp.x; }
};
int main()
{
	D d(2);

	return 0;
}
```
分析
```
D d(2);
1.调用C的构造函数，先生成C(2);
2.再调用c的拷贝构造函数
3.调用B的构造函数
```

初始化的顺序：
```
class A
{
public:
    B b;
    C c;
    A(): c(), b(){} // 初始化的时候还是先b后c
}
```
初始化的顺序为他们被声明的顺序而不是在初始化列表中的顺序

## 可以访问成员对象的public接口
```
class A
{
public:
    D d;
    void print() {d.func();}
}
```
